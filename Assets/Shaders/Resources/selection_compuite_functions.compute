// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CS_transform_fitness_to_probability
#pragma kernel CS_parent_selection
#pragma kernel CS_debug_wang_hash
#pragma kernel CS_cross_over
#pragma kernel CS_mutation_and_copy
#pragma kernel CS_mutation_and_copy_BW
#pragma kernel CS_populate_population
#pragma kernel CS_populate_population_BW


struct MemberIDFitnessPair 
{
    uint  memberID;
    float memberFitness;
};

struct Genes
{
    float2 position;       // screen space 0-1
    float  z_Rotation;     // 0 to tau
    float2 scale;          // scale in quad aligned space, will be clamped
    float3 color;          // the colors of each stroke
    int    texture_ID;     // such a waste of bit space. I only need 2 bits, but paying the cost 8 + padding
};  // Struct size 8 *4 bytes + 1  * 4 = 36 bytes

// ----------------------------------------------------------------------------------------------------
// REsource for all kernels

uint                         _population_pool_size;
uint                         _genes_number_per_member;
RWStructuredBuffer<float>    _population_accumlative_probablities_array;
RWStructuredBuffer<uint2>    _second_gen_parent_ids;                                                  // Buffer has as many members as the population pool size. Each member is made up of an x and a y. The two are parents that produce the next generation

RWStructuredBuffer<Genes>    _second_gen_population_pool;
RWStructuredBuffer<Genes>    _population_pool;

int                          _generation_seed;                                                        // this is used to not generate the same random sequence for all generations.
float                        _fittness_pow_factor;
                                                                                                      
// ----------------------------------------------------------------------------------------------------
// Resource for CS_normalize_population_probabilities

StructuredBuffer <float2>                  _population_fitness_array;
RWStructuredBuffer<MemberIDFitnessPair>    _fittest_member;                                           // this structured buffer only has one member. It is a single int. I am sure there is a way to do this with a groupshared global int, and still read it on the CPU, however since I have to figure out how to do that within unity API I will just use a tiny structured buffer with one member
// ----------------------------------------------------------------------------------------------------
// Resource for CS_wang_hash

RWTexture2D<float4>          _debug_texture;                                                          // this is used to test how well random number generation works
int                          _image_width;                                                            // global image einformation. Used for debuging
int                          _image_height;                                                           // global image einformation. Used for debuging

// ----------------------------------------------------------------------------------------------------
// Resource for CS_parent_selection

// ----------------------------------------------------------------------------------------------------
// Resource for CS_mutation_and_copy

float                        _mutation_rate;
float                        _scale_lower_bound;
float                        _scale_higher_bound;
StructuredBuffer<float2>     _position_domain_buffer;
StructuredBuffer<int4>       _position_domain_argument_buffer;

// ----------------------------------------------------------------------------------------------------
// -------------------- https://www.shadertoy.com/view/WttXWX
#define Tau       6.283185307
#define scale_low _scale_lower_bound
#define scale_up  _scale_higher_bound

// The below macro is used to get a random number which varies across different generations. 

#define rnd(seed, constant)  wang_rnd(seed +triple32(_generation_seed) * constant) 

uint triple32(uint x)
{
    x ^= x >> 17;
    x *= 0xed5ad4bbU;
    x ^= x >> 11;
    x *= 0xac4c1b51U;
    x ^= x >> 15;
    x *= 0x31848babU;
    x ^= x >> 14;
    return x;
}

float wang_rnd(uint seed)
{
    uint rndint = triple32(seed);
    return ((float)rndint) / float(0xFFFFFFFF);                                                       // 0xFFFFFFFF is max unsigned integer in hexa decimal
}

#include "LabColorSpace.cginc"

inline Genes mutate_gene(uint seed, uint geneID) 
{
    Genes toReturn;


    int position_domain_length = _position_domain_argument_buffer[0].x;
    int pos_domain_id = (int)floor(rnd(seed, 51)* (float)position_domain_length);

    toReturn.position = _position_domain_buffer[pos_domain_id] * 2.0 - 1.0;

    //toReturn.position   = float2(rnd(seed, 51),                                                       // Position X. range -1 -> 1
    //                             rnd(seed, 712))* 2.0 - 1.0;                                          // Position Y. range -1 -> 1
                                                                                                      
    toReturn.z_Rotation = rnd(seed, 25) * Tau;                                                        // 0 to 360 degrees or 2 PI for our functions
                                        
    float f = 1. - ((float)geneID / (float)_genes_number_per_member);
    toReturn.scale      = float2(rnd(seed, 82),                                                       // Scale X.
                                 rnd(seed, 7)) *                                                      // Scale Y.
                                 (scale_up - scale_low) * max(0.2, f) + scale_low;                              // Remap to lower and higher bound of the scale range
                              
    float3 CIELab = float3(rnd(seed, 62),     // brush strokes color channel. L
                           rnd(seed, 13),     // brush strokes color channel. a
                           rnd(seed, 662));   // brush strokes color channel. b  



    toReturn.color = lab2rgb(CIELab);
                                                                                                      
    toReturn.texture_ID = floor(rnd(seed, 992) * 4);                                                  // integer id betwen 0 and 3 inclusive 0 and 3. So 4 elements


    return toReturn;
}

inline Genes mutate_gene_BW(uint seed, uint geneID)
{
    Genes toReturn;

    int position_domain_length = _position_domain_argument_buffer[0].x;
    int pos_domain_id = (int)floor(rnd(seed, 51)* (float)position_domain_length);

    toReturn.position = _position_domain_buffer[pos_domain_id] * 2.0 - 1.0;

    //toReturn.position   = float2(rnd(seed, 51),                                                       // Position X. range -1 -> 1
    //                             rnd(seed, 712))* 2.0 - 1.0;                                          // Position Y. range -1 -> 1
                                                                                                      
    toReturn.z_Rotation = rnd(seed, 25) * Tau;                                                        // 0 to 360 degrees or 2 PI for our functions
               
    float f = 1. - ((float)geneID / (float)_genes_number_per_member);
    toReturn.scale      = float2(rnd(seed, 82),                                                       // Scale X.
                                 rnd(seed, 7)) *                                                      // Scale Y.
                                 (scale_up - scale_low) * max(0.2,f)+ scale_low;                             // Remap to lower and higher bound of the scale range
    float val           = rnd(seed, 62);

    toReturn.color      = float3(val, val, val);                                                      // brush strokes color                                                                                                       
    toReturn.texture_ID = floor(rnd(seed, 992) * 4);                                                  // integer id betwen 0 and 3 inclusive 0 and 3. So 4 elements


    return toReturn;
}

inline float inverse_lerp(float value, float a, float b) 
{
    return max(0., value - a) / (b - a);
}

// ----------------------------------------------------------------------------------------------------

[numthreads(1,1,1)]                                                                                   // This will run once, a single thread
void CS_transform_fitness_to_probability(uint3 id : SV_DispatchThreadID)
{
    
    float temp         = 0.0;
    
    float highest_fitness  = 0.0f;
    uint  m_fittest_member = 20000;

    float lowest_fitness   = 1000000000.0;
    for (uint i = 0; i < _population_pool_size; i++) {

        float f = _population_fitness_array[i].x;

        if(f > highest_fitness)                                              // this finds out which member has the highest fitness. This is used for visualisation at the end of the render loop, the fittest member is redrawn-
        {
            highest_fitness  = f;
            m_fittest_member = i;
        }

        if (f < lowest_fitness)
        {
            lowest_fitness = f;
        }
    }

    _fittest_member[0].memberID      = m_fittest_member;
    _fittest_member[0].memberFitness = highest_fitness/ (_population_fitness_array[m_fittest_member].y);


    float total_sum    = 0.0;
    for (uint k = 0; k < _population_pool_size; k++) 
    {
        total_sum  += pow(inverse_lerp(_population_fitness_array[k].x, lowest_fitness, highest_fitness), _fittness_pow_factor);
        _population_accumlative_probablities_array[k] = total_sum;                                     // since I am using only one thread, I dont have to worry about writing to the same cacheline I am reading from and false sharing. 
    }


    temp = 0.0;
    for (uint j = 0; j < _population_pool_size; j++) {
        temp = _population_accumlative_probablities_array[j];
        _population_accumlative_probablities_array[j] = temp / total_sum;                              // actual normalization happens here. Now the fitness of each member is converted to a probablity of the member being selection, with regards to how fit the other members are
    } 


}

// ----------------------------------------------------------------------------------------------------

[numthreads(16,1,1)]                                                                                  // 1 threads per population pool member. change to whatever works for you
void CS_parent_selection(uint3 id : SV_DispatchThreadID)
{
    
    float randomNumber = rnd(id.x, 25);
    uint i = 0;
    for (     ; i < _population_pool_size; i++){
        if(randomNumber <= _population_accumlative_probablities_array[i]) break;
    }

    randomNumber = rnd(id.x, 61);
    uint j = 0;
    for (     ; j < _population_pool_size; j++){
        if(randomNumber <= _population_accumlative_probablities_array[j]) break;
    }
 
    _second_gen_parent_ids[id.x] = uint2(i, j);
}

[numthreads(8, 8, 1)]                                                                         
void CS_debug_wang_hash(uint3 id : SV_DispatchThreadID)
{
    float rand = rnd(_image_width * id.y + id.x, 13);
 
    // used to see if the rand is normalized correctly between 0 and 1
    //if (rand < 0 || rand>1) rand = 1;
    //else rand = 0;
    _debug_texture[id.xy] = float4(rand, rand, rand, 1.0);
}


// ----------------------------------------------------------------------------------------------------

[numthreads(128,1,1)]                                                                                  // 1 threads per gene member. change to whatever works for you
void CS_cross_over(uint3 id : SV_DispatchThreadID)
{
    
    uint  population_id      = floor(id.x / _genes_number_per_member);                                // Since this is a thread per gene, if there are 5 population members with 10 genes each there will be 50 threads. This number indicates which of those for example 5 population member this thread belongs to
    uint  popluation_gene_id = fmod (id.x,  _genes_number_per_member);                                // If the above number is for example is 4, then this thread is dealing with one of the genes of the 4th member. This number indicates which of those 10 genes of the 4 member for example it is. In this example, number 12 would be dealing with the 2 gene of the 3 member if you start counting from one (array count from zero)

    uint2 parents            = _second_gen_parent_ids[population_id];                                 // Look at the _second_gen_parent_ids declerantion for more info on what those two values are

    uint  parentToTakeFrom   = parents.y;

    if (popluation_gene_id < _genes_number_per_member / 2) parentToTakeFrom = parents.x;              // very simple cross over algo. take the first half of the genes from one parent and the second half from the other. 

    _second_gen_population_pool[id.x] =                                                               // Each thread is mapped to a gene of the second generation, so we can easily use id.x to write that gene
        _population_pool[parentToTakeFrom * _genes_number_per_member + popluation_gene_id];           // example: If we want to take 5th gene of the parent.x which is for example population member 3, we would have to first jump to where population 3 starts which is 3 members that consist of ex. 10 genes so we start at 30 and add the 5 which is the gene we want to coppy 
}


[numthreads(128,1,1)]                                                                                  // 1 threads per gene member. change to whatever works for you
void CS_mutation_and_copy(uint3 id : SV_DispatchThreadID)
{
    float rand = rnd(id.x, 45);

    uint  popluation_gene_id = fmod(id.x, _genes_number_per_member);

    if (rand <= _mutation_rate) _population_pool[id.x] = mutate_gene(id.x, popluation_gene_id);
    else _population_pool[id.x] = _second_gen_population_pool[id.x];

}

[numthreads(128, 1, 1)]                                                                                  // 1 threads per gene member. change to whatever works for you
void CS_mutation_and_copy_BW(uint3 id : SV_DispatchThreadID)
{
    float rand = rnd(id.x, 45);

    uint  popluation_gene_id = fmod (id.x,  _genes_number_per_member); 

    if (rand <= _mutation_rate) _population_pool[id.x] = mutate_gene_BW(id.x, popluation_gene_id);
    else _population_pool[id.x] = _second_gen_population_pool[id.x];

}


[numthreads(128, 1, 1)]                                                                                  // 1 threads per gene member. change to whatever works for you
void CS_populate_population(uint3 id : SV_DispatchThreadID)
{
    float rand = rnd(id.x, 156);

    uint  popluation_gene_id = fmod(id.x, _genes_number_per_member);
    _population_pool[id.x] = mutate_gene(id.x, popluation_gene_id);

}

[numthreads(128, 1, 1)]                                                                                  // 1 threads per gene member. change to whatever works for you
void CS_populate_population_BW(uint3 id : SV_DispatchThreadID)
{
    float rand = rnd(id.x, 156);

    uint  popluation_gene_id = fmod(id.x, _genes_number_per_member);
    _population_pool[id.x] = mutate_gene_BW(id.x, popluation_gene_id);

}
